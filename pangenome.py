#!/usr/bin/python

###############################################################################
#
#    pangenome.py version 1.0
#    
#    Calculates the overlapping genes of multiple species and provides files
#    for CIRCOS visualization of the overlapping genomes
#    
#    Copyright (C) 2014 Evan Denmark & Matthew Neave
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

"""
NOTES ABOUT THIS PROGRAM

This program takes in 2 files as input. The first file is a text file containing clusters of genes and the species 
that contain similar genes in this cluster. The second file is a file containing names of FASTA files. Each of these 
FASTA files contains information about the common name of the protein and the amino acid sequence of the protein.

This program allows for visualization of these genomes through the overlapping of similar genes. The output files of this
program can be directly put into CIRCOS visualization software, which shows your circular genomes, including those genes
that are located in one or more of your species. 

The groups file is a text file in the format:
	
	cluster1: speciesA|arbitrary_name1 speciesB|arbitrary_name2 speciesC|arbitrary_name3
	cluster2: speciesB|arbitrary_name4 speciesC|arbitrary_name5 speciesD|arbitrary_name6

The file containing your names of FASTAs is a text file in the format:

	fasta_file1.fasta
	fasta_file2.fasta

Each FASTA file that these names correspond to are in one of the two following formats:
	
	>gi|123456789|gb|arbitrary_name1| common_protein_name1 [Genus species]
	AMINO ACID SEQUENCE
	>gi|987654321|gb|arbitrary_name2| common_protein_name2 [Genus species]
	AMINO ACID SEQUENCE

	or 

	>fig|arbitrary_name1	common_name1
	AMINO ACID SEQUENCE
	>fig|arbitrary_name2	common_name2
	AMINO ACID SEQUENCE

******************SPECIAL NOTE*******************

Each fasta file that you make to be put into this program may have slightly different formatting, depending on how you 
name your sequences. Specifically, this program searches for your names in one of two common methods shown above. In
particular, the first format will be generated by GenBank (thus the gb as the 3rd object in the name), whereas the 
second format is generated by RAST. Either is acceptable for this program, but you may choose to format differently, in
which case you MUST change the function 'get_info(each_line)' in lines 185 to 215.
"""

import argparse

parser = argparse.ArgumentParser(description = 'Please provide a groups file and a file with the names of your fasta files, each on a separate line')
parser.add_argument('groups', help='a groups file containing your gene clusters')
parser.add_argument('files', help='a file with the names of your fasta files you would like to include (each fasta name must be on a separate line)')

groups_file = parser.parse_args().groups
files = parser.parse_args().files

fasta_list = []
fastas = open(files, 'r')					# from the provided file, we make a list of FASTA files
for each_line in fastas:
	each_line = each_line.rstrip('\n')
	fasta_list.append(each_line)

def pangenome(groups_file, fasta_list):
 
    #creating the len_dict
    """
	The len_dict is used to remember all of the common names and lengths of EVERY gene in each species, which are matched to the arbitrary name. 
	The len_dict is in form len_dict = {speciesA:{arb_name1:[com_name, length], arb_name2:[com_name,length]}, speciesB: {arb_name1:[com_name, length], arb_name2:[com_name,length]}}
    """
    len_dict={}
    for the_file in fasta_list:
        
        each_file=open(str(the_file), 'r')
	the_file = the_file.split('.')
	if the_file[0] == 'E':
		
		if the_file[1][0] == 'v':
			species = 'verr'
		elif the_file[2] == 'typeA':
			species = 'pistA'
		elif the_file[2] == 'typeB':
			species = 'pistB'
		else:
			species = the_file[1][:5]
			
	else:	
		species = the_file[0]
	len_dict[species] = {}
        for each_line in each_file:
            if each_line[0] == '>':
				
		    information = get_info(each_line)		
	    	    length = 0
            else:
                #sequence line
                for amino_acid in each_line:
                    length +=3	
	    arb_name = information[0]
	    com_name= information[1]
	    
            len_dict[species][arb_name] = [com_name, length]
        each_file.close()


    # creating the gene_dict
    groups_file = open(str(groups_file), 'r')

    """
	The gene_dict is used to match and remember the genes within each cluster (similar genes), lengths of the cluster as a whole, and which species they correspond to.
	The gene_dict only accounts for the genes that are in MULTIPLE species, NOT THE GENES ONLY IN A SINGLE SPECIES. 
 	The gene_dict is in the form gene_dict = {speciesA: {cluster1: [[arb_name1, arb_name2], [len1, len2]]}, speciesB: {cluster1:[[arb_name1, arbname2], [len1, len2]]}}
    """
    gene_dict = {}
    arb_dict = {}
    for each_line in groups_file:
        # each_line consists of a cluster of genes, each with a different arbitrary name and species it belongs to
	
        each_line = each_line.split()
        cluster = each_line[0].rstrip(':')
        n=0
        for each_segment in each_line:
            # each segment looks like 'species|arbitrary_name'
	    
            if n == 0:
                # cluster name
		n = 1      
            else:
                n+=1
                each_segment = each_segment.split('|')
                species = each_segment[0]
		
                arb_name = each_segment[1]
		# The arb_dict is simply a quick reference of ONLY the genes that are in MULTIPLE SPECIES. Genes that only have a single copy in one species will not be included. 
		arb_dict[arb_name] = 0
                if species not in gene_dict:
                    gene_dict[species] = {}
		    
                            
                if cluster not in gene_dict[species]:
                    gene_dict[species][cluster] = [[],[]]

                gene_dict[species][cluster][0].append(arb_name)
                length = len_dict[species][arb_name][1]
                gene_dict[species][cluster][1].append(length)
             
	"""'
	The cluster_dict is used to remember the lengths of entire clusters (similar genes; essentially genes with very similar function).
	If speciesA has 3 copies of the gene and speciesB only has 1 copy, speciesA will take up more space. The purpose of this dict is to 
	have all of the same genes line up visually. We want the maximum length for all the species. In the example, speciesB will have three slots for the gene and 2 will be empty.
	The cluster dict is in the format cluster_dict= {cluster1: integer, cluster2: integer}
	"""
    
    cluster_dict = {}
    for species in gene_dict:
        for cluster in gene_dict[species]:
	    if cluster not in cluster_dict or cluster_dict[cluster] < sum(gene_dict[species][cluster][1]):
	            cluster_dict[cluster] = sum(gene_dict[species][cluster][1])
		                  
    return len_dict, gene_dict, cluster_dict, arb_dict


def get_info(each_line):
	
	each_line=each_line.split('|')
	if len(each_line) == 2:
		#RAST
		each_line='|'.join(each_line)
		each_line = each_line.lstrip('>')		# stripping down the name line into the information we want
                each_line = each_line.rstrip('\n')
		each_line=str(each_line)
        	each_line=each_line.split('|')
		new = each_line[1].split('\t')
		arb_name = new[0]
		com_name = new[1]
		 
	else:
		#GenBank
	    each_line='|'.join(each_line)
	    
            each_line = each_line.lstrip('>')		# stripping down the name line into the information we want
            each_line = each_line.rstrip('\n')
	    each_line=str(each_line)
            each_line=each_line.split('|')
                
	    arb_name = each_line[3]
		
	    com_spec=each_line[4].lstrip()
            com_spec=com_spec.split()
  	    com_name=com_spec[:(len(com_spec)-2)]
		
	    com_name = '_'.join(com_name)
       return arb_name, com_name


def make_files(groups_file, fasta_list):

    genome = pangenome(groups_file, fasta_list)
    len_dict = genome[0]
    gene_dict = genome[1]
    cluster_dict = genome[2]
    arb_dict=genome[3]

    # The ultimate cluster list is created to have an order in the clusters that we reference.
    ult_cluster_list = []
    for each_species in gene_dict:
    	for cluster in gene_dict[each_species]:
		if cluster not in ult_cluster_list:
			ult_cluster_list.append(cluster)
    ult_cluster_list = sorted(ult_cluster_list)
  
    after_group_len = []
    chromosome = 'pg1'
    for each_species in gene_dict:
        each_species = str(each_species)
        new_file = open(each_species+'_pangenome.txt', 'w')
        start = 0 
	total_len = []
	
	com_file = open(each_species+'_name.txt', 'w')
	
	# ACCOUNT FOR THE OVERLAPPING GENES
	# We want to go through the same cluster order each time. If we simply went through the cluster_dict, the cluster would be out of order and not allign.
	for each_cluster in ult_cluster_list:
		if each_cluster in gene_dict[each_species]:
			# We must extract the information we want (common name of each protein and the start and end of the nucleotide sequence corresponding to the protein.
			for each_arb_name in gene_dict[each_species][each_cluster][0]:
				common_name = len_dict[each_species][each_arb_name][0]
				length = len_dict[each_species][each_arb_name][1]
				
				end = start + length
				line = str(chromosome)+'\t'+str(start)+'\t'+str(end)+'\n'
				new_file.write(line)
				com_line = str(each_species)+'\t'+str(common_name)+'\t'+str(start)+'\t'+str(end)+'\n'
				com_file.write(com_line)
				start = end+1
		# The sum of total_len is current place in which we are putting genes on the genome
		# Each cluster must start and end in the same place, regardless if the species contains that gene at all
		# The purpose of this is so that all the genes line up
		total_len.append(cluster_dict[each_cluster])
		start= sum(total_len)
	

	# ACCOUNT FOR THE INDIVIDUAL GENES (ONLY A SINGLE COPY IN ONE SPECIES)
 	start=sum(total_len)+sum(after_group_len)
	for each_arb_name in len_dict[each_species]:
		if each_arb_name not in arb_dict:
			common_name = len_dict[each_species][each_arb_name][0]
			length = len_dict[each_species][each_arb_name][1]
			end=start+length
			line= str(chromosome)+'\t'+str(start)+'\t'+str(end)+'\n'
			new_file.write(line)
			com_line=str(each_species)+'\t'+str(common_name)+'\t'+str(start)+'\t'+str(end)+'\n'
			com_file.write(com_line)
			start = end+1
			after_group_len.append(length)
		
	new_file.close()
	com_file.close()
    
    # CREATE THE KARYOTYPE FILE (FOR CIRCOS VISUALIZATION)
    end = str(end)
    karyotype = open('karyotype.panGenome.txt', 'w')
    karyotype.write('chr'+'\t'+'-'+'\t'+'pg1'+'\t'+'1'+'\t'+'0'+'\t'+end+'\t'+'black')
    karyotype.close()

make_files(groups_file, fasta_list)
